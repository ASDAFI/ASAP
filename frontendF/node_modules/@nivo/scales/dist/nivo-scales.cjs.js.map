{"version":3,"file":"nivo-scales.cjs.js","sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"names":["precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","format","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","minValue","maxValue","min","max","stacked","reverse","clamp","nice","minStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","createBandScale","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","sign","base","some","v","Error","hasMixedSign","filter","Math","scaleLog","createSymlogScale","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","stackedValue","generateSeriesXY","series","xScaleSpec","yScaleSpec","x","generateSeriesAxis","y","scaleSpec","getValue","d","setValue","serie","parseFloat","String","values","push","sortBy","uniq","uniqBy","sort","last","stackAxis","xy","otherAxis","compare","isDate","stack","find","stackValue","head","stackX","stackY","timeDay","timeInterval","step","getDate","start","end","floor","utcDay","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","bandwidth","offset","width","height","nestedSeries","map","nestSerieData","xScale","yScale","computedSeries","position","Array","isArray","matches","match","amount","timeType","originalStop","stop","every","Number","_timeType$every","ticks","interval","isFinite"],"mappings":"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"}